runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
### calculate log risk ratios and corresponding sampling variances
dat <- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
### random-effects model, using log risk ratios and variances as input
### note: method="REML" is the default, so one could leave this out
rma(yi, vi, data=dat, method="REML")
### random-effects model, using log risk ratios and standard errors as input
### note: the second argument of rma() is for the *variances*, so we use the
### named argument 'sei' to supply the standard errors to the function
dat$sei <- sqrt(dat$vi)
res <- rma(yi, sei=sei, data=dat)
res
res
?rma()
rma(yi, vi, mods=cbind(ablat), data=dat)
res.mod <- rma(yi, vi, mods=cbind(ablat), data=dat)
res.mod$k.all
runApp()
runApp()
res.mod.nointr <- rma(yi, vi, mods= ~ as_factor(ablat) - 1, data=dat)
res.mod.nointr
# with intercept
res.mod <- rma(yi, vi, mods=cbind(alloc), data=dat)
# with intercept
res.mod <- rma(yi, vi, mods=~ as_factor(alloc), data=dat)
res.mod.nointr
res.mod.nointr
res.mod.nointr <- rma(yi, vi, mods= ~ as_factor(alloc) - 1, data=dat)
res.mod.nointr
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
res.mod
runApp()
runApp()
runApp()
runApp()
runApp()
res.mod.nointr
View(res.mod.nointr)
res.mod.nointr$b
runApp()
runApp()
runApp()
View(res.mod.nointr)
runApp()
runApp()
runApp()
b <- c(1, 2, 3)
sprintf("Test of Moderators (coefficients 2:%.0f)", length(b))
intrcpt <- TRUE
b <- c(1, 2, 3)
if((intrcpt = TRUE) & (length(b) > 2)){
sprintf("Test of Moderators (coefficients 2:%.0f)", length(b))
} else if ((intrcpt = TRUE) & (length(b) == 2)){
paste("Test of Moderators (coefficient 2")
} else if (intrcpt = FALSE){
sprintf("Test of Moderators (coefficients 1:%.0f)", length(b))
}
if((intrcpt == TRUE) & (length(b) > 2)){
sprintf("Test of Moderators (coefficients 2:%.0f)", length(b))
} else if ((intrcpt == TRUE) & (length(b) == 2)){
paste("Test of Moderators (coefficient 2")
} else if (intrcpt == FALSE){
sprintf("Test of Moderators (coefficients 1:%.0f)", length(b))
}
intrcpt <- FALSE
b <- c(1, 2, 3)
if((intrcpt == TRUE) & (length(b) > 2)){
sprintf("Test of Moderators (coefficients 2:%.0f)", length(b))
} else if ((intrcpt == TRUE) & (length(b) == 2)){
paste("Test of Moderators (coefficient 2")
} else if (intrcpt == FALSE){
sprintf("Test of Moderators (coefficients 1:%.0f)", length(b))
}
intrcpt <- FALSE
b <- c(1, 2)
if((intrcpt == TRUE) & (length(b) > 2)){
sprintf("Test of Moderators (coefficients 2:%.0f)", length(b))
} else if ((intrcpt == TRUE) & (length(b) == 2)){
paste("Test of Moderators (coefficient 2")
} else if (intrcpt == FALSE){
sprintf("Test of Moderators (coefficients 1:%.0f)", length(b))
}
intrcpt <- TRUE
if((intrcpt == TRUE) & (length(b) > 2)){
sprintf("Test of Moderators (coefficients 2:%.0f)", length(b))
} else if ((intrcpt == TRUE) & (length(b) == 2)){
paste("Test of Moderators (coefficient 2")
} else if (intrcpt == FALSE){
sprintf("Test of Moderators (coefficients 1:%.0f)", length(b))
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(res.mod)
View(res.mod.nointr)
res.mod.knha <- rma(yi, vi, mods=~ as_factor(alloc), data=dat, knha = TRUE)
View(res.mod.knha)
res.mod.knha
View(res.mod)
runApp()
runApp()
runApp()
res.mod$se
runApp()
runApp()
runApp()
data.table("x" = c(1.00, 2.3132, 2.30181))
data.table("x" = c(1.00, 2.3132, 2.30181),
"z" = c("a", "b", "z"))
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp('~/Documents/FWF/Shiny App/test')
runApp('~/Documents/FWF/Shiny App/test')
runApp()
runApp('~/Documents/FWF/Shiny App/test')
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?actionBttn()
runApp()
runApp()
runApp()
runApp()
runApp()
h2("Test")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
?isTruthy
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# with intercept
res.mod <- rma(yi, vi, mods=~ as_factor(alloc), data=dat)
### calculate log risk ratios and corresponding sampling variances
dat <- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
### random-effects model, using log risk ratios and variances as input
### note: method="REML" is the default, so one could leave this out
rma(yi, vi, data=dat, method="REML")
### random-effects model, using log risk ratios and standard errors as input
### note: the second argument of rma() is for the *variances*, so we use the
### named argument 'sei' to supply the standard errors to the function
dat$sei <- sqrt(dat$vi)
res <- rma(yi, sei=sei, data=dat)
# with intercept
res.mod <- rma(yi, vi, mods=~ as_factor(alloc), data=dat)
res.mod.knha <- rma(yi, vi, mods=~ as_factor(alloc), data=dat, knha = TRUE)
res.mod.nointr <- rma(yi, vi, mods= ~ as_factor(alloc) - 1, data=dat)
res.mod.nointr.knha <- rma(yi, vi, mods= ~ as_factor(alloc) - 1, data=dat, knha = TRUE)
res.mod
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
mods <- c("year", "pub")
catmod <- "pub"
mods_new <- apply(mods[catmod], 1, function(x) paste0("as_factor(", x, ")")
mods_new <- apply(mods[catmod], 1, function(x) paste0("as_factor(", x, ")"))
mods[catmod]
mods[which(catmod)]
mods[c(catmod)]
mods["pub"]
mods_new <- apply(catmod, 1, function(x) paste0("as_factor(", x, ")"))
mods_new <- paste0("as_factor(", catmod, ")"))
mods_new <- paste0("as_factor(", catmod, ")")
catmod <- c("pub", "year")
mods_new <- paste0("as_factor(", catmod, ")")
mods_new
mods_new <- paste0("as_factor(", catmod, ")", collapse = "")
mods_new <- paste0("as_factor(", catmod, ")", sep = "")
mods_new <- paste0("as_factor(", catmod, ")")
mods_new <- ifelse(catmod %in% mod, paste0("as_factor(", catmod, ")"), paste0(mod))
mods_new <- ifelse(catmod %in% mods, paste0("as_factor(", catmod, ")"), paste0(mods))
mods_new <- ifelse(mods %in% catmod, paste0("as_factor(", catmod, ")"), paste0(mods))
catmod <- c("pub")
mods_new <- ifelse(mods %in% catmod, paste0("as_factor(", catmod, ")"), paste0(mods))
runApp()
# paste all moderators as formula
mods_formula <- paste0("data_reac$DT[[", "'", mods, "'", "]]", collapse = " + ")
mods_formula
# paste all moderators as formula
mods_formula <- ifelse(mods %in% catmod,
paste0("as_factor(", "data_reac$DT[[", "'", mods, "'", "]])", collapse = " + "),
paste0("data_reac$DT[[", "'", mods, "'", "]]", collapse = " + "))
mods_formula
# paste all moderators as formula
mods_prep <- ifelse(mods %in% catmod,
paste0("as_factor(data_reac$DT[[", "'", mods, "'", "]])"),
paste0("data_reac$DT[[", "'", mods, "'", "]]"))
mods_prep
mods_formula <- paste0(mods_prep, collapse = " + ")
mods_formula
mods <- c("year", "pub")
catmod <- c("pub")
# paste all moderators as formula
mods_formula <- paste0(
ifelse(mods %in% catmod,
paste0("as_factor(data_reac$DT[[", "'", mods, "'", "]])"),
paste0("data_reac$DT[[", "'", mods, "'", "]]")), collapse = " + ")
mods_formula
runApp()
runApp()
l <- c("data_reac$DT[['year']]", "as_factor(data_reac$DT[['pub']])1")
# shorten name in object
lapply(l, function(x){
attr(x$beta, "dimnames")[[1]] <- gsub(".*)","", attr(x$beta, "dimnames")[[1]])
x
})
# shorten name in object
gsub(".*)","", l)
# shorten name in object
gsub('(.*?[^\\])', l)
?gsub()
# shorten name in object
grep('(.*?[^\\])', l)
# shorten name in object
grep('(.*?[^\\])', l, value = TRUE)
library(stringr)
library(tidyverse)
str_view(l)
str_view(l, "data_reac")
str_view(l, ".*)")
str_view(l, "'[^']*[^']*'")
str_view(l, "(?')[^']*:[^']*(?=')")
str_view(l, "(?')[^']*:[^']*(?')")
str_view(l, "(?')[^']*:[^']*(?')", pearl = TRUE)
?str_view
grep("(?')[^']*:[^']*(?')", l, pearl = TRUE)
grep("(?')[^']*:[^']*(?')", l, perl = TRUE)
grep("'[^']*[^']*'", l, perl = TRUE)
grep("'[^']*[^']*'", l)
?gsub
regexpr("'[^']*[^']*'", l)
gregexpr("'[^']*[^']*'", l)
grepl("'[^']*[^']*'", l)
grep("'[^']*[^']*'", l)
grep("'[^']*[^']*'", l, value = TRUE)
grep("'[^']*[^']*'", "data_reac$DT[['year']]")
str_match("data_reac$DT[['year']]", "'[^']*[^']*'")
str_match(l, "'[^']*[^']*'")
as.vector(str_match(l, "'[^']*[^']*'"))
str_view(l, ".*)")
str_view("as_factor(data_reac$DT[['pub']])1", ".*)")
gsub(".*)","", l)
gsub(".*]]","", l)
?str_replace
str_replace(gsub(".*]]","", l), ")", ":")
str_replace("a)b", ")", ":")
str_replace("a)b", ")", "-")
str_replace("a)b", "\)", "-")
str_replace("a)b", "\\)", "-")
str_replace(gsub(".*]]","", l), "\\)", ":")
grep("'[^']*[^']*'", l)
as.vector(str_match(l, "'[^']*[^']*'"))
str <- as.vector(str_match(l, "'[^']*[^']*'"))
str_replace(gsub(".*]]","", str), "\\)", ":")
paste0(
as.vector(str_match(l, "'[^']*[^']*'")),
str_replace(gsub(".*]]","", l), "\\)", ":")
)
runApp()
### calculate log risk ratios and corresponding sampling variances
dat <- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
?rma()
res.reg <- rma(yi, vi, mods=cbind(ablat, year), data=dat)
res.reg
res.reg$beta, "dimnames")[[1]]
attr(res.reg$beta, "dimnames")[[1]]
attr(res.reg$beta, "dimnames")
vars <- attr(res.reg$beta, "dimnames")[[1]]
vars <- attr(res.reg$beta, "dimnames")[[1]][-1]
runApp()
runApp()
runApp()
mods <- c('[["year"]]', '[["pub"]]')
stringi::stri_extract_all_regex(mods, '(?<=").*?(?=")')
as.vector(stringi::stri_extract_all_regex(mods, '(?<=").*?(?=")'))
unlist(stringi::stri_extract_all_regex(mods, '(?<=").*?(?=")'))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
res.reg
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
### calculate log risk ratios and corresponding sampling variances
dat <- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
### random-effects model, using log risk ratios and variances as input
### note: method="REML" is the default, so one could leave this out
rma(yi, vi, data=dat, method="REML")
### random-effects model, using log risk ratios and standard errors as input
### note: the second argument of rma() is for the *variances*, so we use the
### named argument 'sei' to supply the standard errors to the function
dat$sei <- sqrt(dat$vi)
res <- rma(yi, sei=sei, data=dat)
res
# with intercept
res.mod <- rma(yi, vi, mods=~ as_factor(alloc), data=dat)
res.mod.knha <- rma(yi, vi, mods=~ as_factor(alloc), data=dat, knha = TRUE)
res.mod.knha
View(res.mod.knha)
View(res.mod)
runApp()
runApp()
runApp()
runApp()
l <- list()
l$a <- "a"
l$b <- "b"
names(l)
names(l) <- c("c", "d")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?data.table::merge()
df<- data.table::merge(as.data.table(params$sbgrp_df_coeff$intrcpt[,-1]),
as.data.table(params$sbgrp_df_coeff$intrcpt[, -1]),
by = "coeff", suffixes = c("", "_knha"))
library(data.table)
df<- data.table::merge(as.data.table(params$sbgrp_df_coeff$intrcpt[,-1]),
as.data.table(params$sbgrp_df_coeff$intrcpt[, -1]),
by = "coeff", suffixes = c("", "_knha"))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# with intercept
res.mod <- rma(yi, vi, mods=~ as_factor(alloc), data=dat)
### calculate log risk ratios and corresponding sampling variances
dat <- escalc(measure="RR", ai=tpos, bi=tneg, ci=cpos, di=cneg, data=dat.bcg)
### random-effects model, using log risk ratios and variances as input
### note: method="REML" is the default, so one could leave this out
rma(yi, vi, data=dat, method="REML")
### random-effects model, using log risk ratios and standard errors as input
### note: the second argument of rma() is for the *variances*, so we use the
### named argument 'sei' to supply the standard errors to the function
dat$sei <- sqrt(dat$vi)
res <- rma(yi, sei=sei, data=dat)
res
# with intercept
res.mod <- rma(yi, vi, mods=~ as_factor(alloc), data=dat)
res.mod
runApp()
runApp()
runApp()
runApp()
res.mod.knha <- rma(yi, vi, mods=~ as_factor(alloc), data=dat, knha = TRUE)
res.mod.knha$QM
res.mod.knha$QMp
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
